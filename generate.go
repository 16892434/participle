package participle

import (
	"fmt"
	"io"
	"reflect"
	"strings"
)

func localTypeName(n reflect.Type) string {
	parts := strings.Split(n.String(), ".")
	return parts[len(parts)-1]
}

func rootPackageName(n reflect.Type) string {
	parts := strings.Split(indirectType(n).String(), ".")
	return parts[0]
}

// Generate a parser.
func (p *Parser) Generate(w io.Writer) error {
	ids := buildNodeIDs(p.root)
	types := []string{p.typ.Elem().String()}
	push := func(n reflect.Type) { types = append(types, localTypeName(n)) }
	pop := func() { types = types[:len(types)-1] }
	fmt.Fprint(w, "// Code generated by Participle. DO NOT EDIT.\n")
	fmt.Fprintln(w)
	fmt.Fprintf(w, "package %s\n", rootPackageName(p.typ))
	fmt.Fprintln(w)
	fmt.Fprintln(w, `import (
		"strconv"

		"github.com/alecthomas/participle/v2"
		"github.com/alecthomas/participle/v2/lexer"
	)`)
	fmt.Fprintln(w)
	fmt.Fprintf(w, "func (p *%s) Parse(lex *lexer.PeekingLexer) error {\n", localTypeName(p.typ.Elem()))
	fmt.Fprintf(w, "  tokens, err := parse%d(lex, p)\n", ids[p.root])
	fmt.Fprintf(w, "  if err != nil { return err }\n")
	fmt.Fprintf(w, "  if tokens == nil {\n")
	fmt.Fprintf(w, "    tok, _ := lex.Peek(0)\n")
	fmt.Fprintf(w, "    if tok.EOF() { return nil }\n")
	fmt.Fprintf(w, "    return participle.UnexpectedTokenError{tok, \"\"}\n")
	fmt.Fprintf(w, "  }\n")
	fmt.Fprintf(w, "  return nil\n")
	fmt.Fprintf(w, "}\n")
	return visit(p.root, func(n node, next func() error) error {
		if n, ok := n.(*strct); ok {
			push(n.typ)
			defer pop()
		}
		into := types[len(types)-1]
		fmt.Fprintln(w)
		fmt.Fprintf(w, "// %s (%s)\n", strings.Split(ebnf(n), "\n")[0], reflect.Indirect(reflect.ValueOf(n)).Type().Name())
		fmt.Fprintf(w, "func parse%d(lex *lexer.PeekingLexer, owner *%s) ([]string, error) {\n", ids[n], into)
		switch n := n.(type) {
		case *strct:
			if n.posFieldIndex != nil {
				fmt.Fprintf(w, "  start, _ := lex.Peek(0)\n")
			}
			if n.tokensFieldIndex != nil {
				fmt.Fprintf(w, "  startIndex := lex.RawCursor()\n")
			}
			fmt.Fprintf(w, "  tokens, err := parse%d(lex, owner)\n", ids[n.expr])
			fmt.Fprintf(w, "  if err != nil || tokens == nil { return nil, err }\n")
			if n.posFieldIndex != nil {
				fmt.Fprintf(w, "  owner.Pos = start.Pos\n")
			}
			if n.endPosFieldIndex != nil {
				fmt.Fprintf(w, "  end, _ := lex.Peek(0)\n")
				fmt.Fprintf(w, "  owner.EndPos = end.Pos\n")
			}
			if n.tokensFieldIndex != nil {
				fmt.Fprintf(w, "  owner.Tokens = lex.Range(startIndex, lex.RawCursor())\n")
			}
			fmt.Fprintf(w, "  return tokens, nil\n")

		case *disjunction:
			fmt.Fprintf(w, "  var (candidate = lex.Clone(); lastErr error)\n")
			for _, alt := range n.nodes {
				fmt.Fprintf(w, "  // %s\n", alt.String())
				fmt.Fprintf(w, "  if tokens, err := parse%d(candidate, owner); err != nil || tokens == nil {\n", ids[alt])
				fmt.Fprintf(w, "    lastErr = err\n")
				fmt.Fprintf(w, "    candidate.Set(lex)\n")
				fmt.Fprintf(w, "  } else if tokens != nil {\n")
				fmt.Fprintf(w, "    lex.Set(candidate)\n")
				fmt.Fprintf(w, "    return tokens, nil\n")
				fmt.Fprintf(w, "  }\n")
			}
			fmt.Fprintf(w, "  lex.Set(candidate)\n")
			fmt.Fprintf(w, "  return nil, lastErr\n")

		case *sequence:
			fmt.Fprintf(w, "  var all []string\n")
			for link := n; link != nil; link = link.next {
				fmt.Fprintf(w, "  // %s\n", link.node)
				if link.head {
					fmt.Fprintf(w, "  if tokens, err := parse%d(lex, owner); err != nil || tokens == nil {\n", ids[link.node])
					fmt.Fprintf(w, "    return nil, err\n")
					fmt.Fprintf(w, "  } else {\n")
					fmt.Fprintf(w, "    all = append(all, tokens...)\n")
					fmt.Fprintf(w, "  }\n")
				} else {
					fmt.Fprintf(w, "  if tokens, err := parse%d(lex, owner); err != nil {\n", ids[link.node])
					fmt.Fprintf(w, "    return nil, err\n")
					fmt.Fprintf(w, "  } else if tokens == nil {\n")
					fmt.Fprintf(w, "    tok, _ := lex.Peek(0)\n")
					fmt.Fprintf(w, "    return nil, participle.UnexpectedTokenError{tok, %q}\n", link.node)
					fmt.Fprintf(w, "  } else {\n")
					fmt.Fprintf(w, "    all = append(all, tokens...)\n")
					fmt.Fprintf(w, "  }\n")
				}
			}
			fmt.Fprintf(w, "  return all, nil")

		case *parseable:
			panic("not implemented")

		case *capture:
			owner := "owner"
			fieldType := n.field.Type
			destType := fieldType
			switch fieldType.Kind() { // nolint: exhaustive
			case reflect.Ptr:
				destType = fieldType.Elem()
				owner = "el"
				fmt.Fprintf(w, "  %s := new(%s)\n", owner, localTypeName(n.field.Type.Elem()))

			case reflect.Slice:
				destType = fieldType.Elem()
				owner = "el"
				fmt.Fprintf(w, "  el := &%s{}\n", localTypeName(destType))
			}
			fmt.Fprintf(w, "  tokens, err := parse%d(lex, %s)\n", ids[n.node], owner)
			fmt.Fprintf(w, "  if err != nil || tokens == nil { return nil, err }\n")
			owner = fmt.Sprintf("owner.%s", n.field.Name)
			switch destType.Kind() { // nolint: exhaustive
			case reflect.String:
				fmt.Fprintf(w, "  for _, tok := range tokens {\n")
				fmt.Fprintf(w, "    %s += tok\n", owner)
				fmt.Fprintf(w, "  }\n")

			case reflect.Int:
				fmt.Fprintf(w, "  for _, tok := range tokens {\n")
				fmt.Fprintf(w, "    if n, err := strconv.ParseInt(tok, 10, %d); err != nil {\n", sizeOfKind(n.field.Type.Kind()))
				fmt.Fprintf(w, "      owner.%s++\n", n.field.Name)
				fmt.Fprintf(w, "    } else {\n")
				fmt.Fprintf(w, "      owner.%s = %s(n)\n", n.field.Name, n.field.Type)
				fmt.Fprintf(w, "    }\n")
				fmt.Fprintf(w, "  }\n")
			}
			switch fieldType.Kind() { // nolint: exhaustive
			case reflect.Ptr:
				fmt.Fprintf(w, "  owner.%s = el\n", n.field.Name)
			case reflect.Slice:
				fmt.Fprintf(w, "  owner.%s = append(owner.%s, el)\n", n.field.Name, n.field.Name)
			}
			fmt.Fprintf(w, "  return []string{}, nil\n")

		case *reference:
			fmt.Fprintf(w, "  tok, err := lex.Peek(0)\n")
			fmt.Fprintf(w, "  if err != nil || tok.Type != %d { return nil, err }\n", n.typ)
			fmt.Fprintf(w, "  _, _ = lex.Next()\n")
			fmt.Fprintf(w, "  return []string{tok.Value}, nil\n")

		case *negation:
			panic("not implemented")

		case *literal:
			fmt.Fprintf(w, "  tok, err := lex.Peek(0)\n")
			fmt.Fprintf(w, "  if err != nil || tok.Value != %q ", n.s)
			if n.t != -1 {
				fmt.Fprintf(w, "|| tok.Type != %d ", n.t)
			}
			fmt.Fprintf(w, "{ return nil, err }\n")
			fmt.Fprintf(w, "  _, _ = lex.Next()\n")
			fmt.Fprintf(w, "  return []string{tok.Value}, nil\n")

		case *group:
			min, max := n.minMax()
			fmt.Fprintf(w, "  var ( matches int; tokens []string )\n")
			fmt.Fprintf(w, "  for {\n")
			fmt.Fprintf(w, "    sub, err := parse%d(lex, owner)\n", ids[n.expr])
			fmt.Fprintf(w, "    if err != nil {\n")
			fmt.Fprintf(w, "      return nil, err\n")
			fmt.Fprintf(w, "    } else if sub == nil {\n")
			fmt.Fprintf(w, "      break\n")
			fmt.Fprintf(w, "    }\n")
			fmt.Fprintf(w, "    tokens = append(tokens, sub...)\n")
			fmt.Fprintf(w, "    matches++\n")
			fmt.Fprintf(w, "  }\n")
			fmt.Fprintf(w, "  if ")
			if min > 0 {
				fmt.Fprintf(w, "matches < %d || ", min)
			}
			fmt.Fprintf(w, "matches >= %d { return nil, nil }\n", max)
			fmt.Fprintf(w, "  return tokens, nil\n")

		default:
			panic(fmt.Sprintf("unsupported node type %T", n))
		}
		fmt.Fprintf(w, "}\n")
		return next()
	})
}

func buildNodeIDs(n node) map[node]int {
	sequence := 0
	ids := map[node]int{}
	_ = visit(n, func(n node, next func() error) error {
		if _, ok := ids[n]; ok {
			return nil
		}
		ids[n] = sequence
		sequence++
		return next()
	})
	return ids
}
